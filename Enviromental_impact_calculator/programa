from antlr4 import *
import os
import sys

# Agregar el directorio de la gramática C al path
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.join(current_dir, '..', 'C_grammar'))

# Importaciones de Python
from Python3Lexer import Python3Lexer
from Python3Parser import Python3Parser
from Python3ParserVisitor import Python3ParserVisitor

# Importaciones de Java
from Java20Lexer import Java20Lexer
from Java20Parser import Java20Parser
from Java20ParserVisitor import Java20ParserVisitor

# Importaciones de C
from CLexer import CLexer
from CParser import CParser
from CVisitor import CVisitor

class ImpactVisitor(ParseTreeVisitor):
    def __init__(self):
        self.impact_scores = {
            'arithmetic': 1,  # Operaciones aritméticas básicas
            'loop': 2,       # Bucles
            'recursion': 3,  # Recursión
            'condition': 1,  # Condicionales (if, switch)
            'function_call': 2,  # Llamadas a funciones
            'memory_op': 2   # Operaciones de memoria
        }
        self.total_impact = 0
        self.operations = {}

    def visitChildren(self, ctx):
        if not ctx:
            return
        for child in ctx.getChildren():
            self.visit(child)

    def analyze_operation(self, op_type):
        self.operations[op_type] = self.operations.get(op_type, 0) + 1
        self.total_impact += self.impact_scores[op_type]

class LanguageSpecificVisitor:
    class PythonVisitor(Python3ParserVisitor, ImpactVisitor):
        def __init__(self):
            super().__init__()

        def visitFor_stmt(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

        def visitWhile_stmt(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

    class JavaVisitor(Java20ParserVisitor, ImpactVisitor):
        def __init__(self):
            super().__init__()

        def visitForStatement(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

        def visitWhileStatement(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

    class CVisitor(CVisitor, ImpactVisitor):
        def __init__(self):
            super().__init__()

        def visitFor_statement(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

        def visitWhile_statement(self, ctx):
            self.analyze_operation('loop')
            return self.visitChildren(ctx)

class EnvironmentalImpactAnalyzer:
    def __init__(self):
        self.visitors = {
            'python': LanguageSpecificVisitor.PythonVisitor(),
            'java': LanguageSpecificVisitor.JavaVisitor(),
            'c': LanguageSpecificVisitor.CVisitor()
        }

    def analyze_code(self, source_code, language):
        try:
            if language.lower() == 'python':
                lexer = Python3Lexer(InputStream(source_code))
                parser = Python3Parser(CommonTokenStream(lexer))
                tree = parser.file_input()
            elif language.lower() == 'java':
                lexer = Java20Lexer(InputStream(source_code))
                parser = Java20Parser(CommonTokenStream(lexer))
                tree = parser.compilationUnit()
            elif language.lower() == 'c':
                lexer = CLexer(InputStream(source_code))
                parser = CParser(CommonTokenStream(lexer))
                tree = parser.compilationUnit()
            else:
                raise ValueError(f"Lenguaje no soportado: {language}")

            visitor = self.visitors[language.lower()]
            visitor.visit(tree)

            return {
                'impact_score': visitor.total_impact,
                'operations': visitor.operations
            }
        except Exception as e:
            print(f"Error al analizar el código: {str(e)}")
            return None

    def get_environmental_score(self, analysis_result):
        if not analysis_result:
            return 0
        
        base_score = 100
        impact_penalty = analysis_result['impact_score'] * 0.5
        final_score = base_score - impact_penalty
        return max(0, min(100, final_score))

def main():
    analyzer = EnvironmentalImpactAnalyzer()
    
    input_type = input("¿Desea ingresar código directamente (1) o desde un archivo (2)? ")
    
    if input_type == "1":
        source_code = input("Ingrese el código a analizar: ")
    else:
        file_path = input("Ingrese la ruta del archivo: ")
        with open(file_path, 'r', encoding='utf-8') as file:
            source_code = file.read()
    
    language = input("Ingrese el lenguaje (python/java/c): ").lower()
    
    analysis = analyzer.analyze_code(source_code, language)
    if analysis:
        score = analyzer.get_environmental_score(analysis)
        
        print("\nResultados del análisis:")
        print(f"Score de amigabilidad ambiental: {score:.2f}/100")
        print("\nDesglose de operaciones:")
        for op, count in analysis['operations'].items():
            print(f"{op}: {count} operaciones")

if __name__ == "__main__":
    main()